&НаСервере
Процедура ВставитьПроверкиНаСервере()

          //Входная - строка формулы
         
					Значение				= Входная + " ";
					ЗначениеДляОпераций		= Значение;
					Значение 				= СтрЗаменить(СтрЗаменить(Значение, "[", "(["), "]", "])"); //Помещаю все статьи в скобки
					Значение				= СтрЗаменить(СтрЗаменить(Значение, "<", "(<"), ">", ">)"); //Помещаю все константы в скобки
					ТаблицаПоиска			= Новый ТаблицаЗначений;
					Идентификатор			= 1;
					ТекущаяВложенность  	= 0;
					Вложенность				= 0;
					МаксимальнаяВложенность = 0;
					МассивРодителей			= Новый Массив;
					
					//Переменные поиска чисел не статей
					МассивЧиселНеСтатей		= Новый Массив;              			//Числа тоже нужно взять в скобки, но для этого
					МассивПройденных		= Новый Массив;							        //их сначала нужно найти
					ТекущееЧислоНеСтатья	= "";
					НаборЦифр				= "0123456789.#";
					ЧислоНачато				= Ложь;
					
					Для О = 1 по СтрДлина(Значение) Цикл //Посимвольный обход формулы
						
						ТекущийСимвол 		= Сред(Значение, О, 1);
						ПредыдущийСимвол	= ?(ЧислоНачато, ПредыдущийСимвол, ?(О = 1, "", Сред(Значение, О - 1, 1)));
						СледующийСимвол		= ?(О = СтрДлина(Значение), "", Сред(Значение, О + 1, 1)); 
						
						Если ПредыдущийСимвол 		= " " 
							Или ПредыдущийСимвол 	= "("  Тогда   							            //Если предыдущий символ ( , или пробел -> Обычное число
							ПредыдущийСимволДоступен = Истина;                         		//Если, например, [, то статья, хотя вроде тоже цифра
						Иначе
							ПредыдущийСимволДоступен = Ложь;
						КонецЕсли; 
						
						Если Не ЧислоНачато Тогда                                       //Если это не первая цифра числа
							
							Если СтрНайти(НаборЦифр, ТекущийСимвол) > 0 И ПредыдущийСимволДоступен Тогда	//Если цифра и Символ = ( Или пробел		
								ЧислоНачато 			= Истина;                                                 //Признак начала обработки числа
								ТекущееЧислоНеСтатья 	= ТекущийСимвол;			                                //Запись первой цифры числа
							Иначе	
								ЧислоНачато = Ложь;		                                                      //Если не цифра, то запись не начнется
							КонецЕсли; 
							
														
						Иначе      						                                                          //Если число уже было начато и это - не первая цифра
							
							Если СтрНайти(НаборЦифр, ТекущийСимвол) > 0 Тогда		  									                     //Если цифра числа                    	
								ТекущееЧислоНеСтатья 	= ТекущееЧислоНеСтатья + ТекущийСимвол;
							Иначе                                                                                     	//Если число закончилось и это уже не цифра
								МассивЧиселНеСтатей.Добавить(ПредыдущийСимвол + ТекущееЧислоНеСтатья + ТекущийСимвол);	  //Добавляем в массив чисел с запасом в 1 символ слева и справа	
								ЧислоНачато 			= Ложь;                                                                 //для того, чтобы случайно не заменить еще и какую-нибудь статю ([20] и 20, например)
								ТекущееЧислоНеСтатья 	= "";
							КонецЕсли;
							
						КонецЕсли;
												
					КонецЦикла;
														
					Для каждого ЧислоНеСтатья Из МассивЧиселНеСтатей Цикл     								              //Обход полученного массива
						
						Пройдено 				= Ложь;
						РазделениеОдинаковых 	= "";
						
						Для каждого ЧислоПройденное Из МассивПройденных Цикл                               	  //Чтобы не повторять СтрЗаменить для одинаковых чисел 2 раза
							Если ЧислоПройденное = ЧислоНеСтатья Тогда
								Пройдено = Истина;
								Прервать;
							КонецЕсли; 
						КонецЦикла; 
						
						Если Пройдено Тогда
							Продолжить;
						Иначе
							МассивПройденных.Добавить(ЧислоНеСтатья);
						КонецЕсли; 
						
						Левый 	= Лев(ЧислоНеСтатья, 1);                                                	//Получаем левый и правый запасные знаки, которые добавляли к числу ранее
						Правый  = Прав(ЧислоНеСтатья, 1);
						
						ЧислоБезБоковых = СтрЗаменить(ЧислоНеСтатья		, Левый	, "");                      //Убираем эти запасные знаки, чтобы получить чистое число
						ЧислоБезБоковых = СтрЗаменить(ЧислоБезБоковых	, Правый, "");
						ЧислоФинальное	= Левый + "(" + ЧислоБезБоковых + ")" + Правый;                   //Добавляем скобки и возвращаем знаки
						
						Значение = СтрЗаменить(Значение, ЧислоНеСтатья, ЧислоФинальное);                  //Заменяем в формуле
						
					КонецЦикла; 
					
					ЧислоСиволов			= СтрДлина(Значение);

					
					ТаблицаПоиска.Колонки.Добавить("Идентификатор");     	  //Таблица для поиска отдельных частей 
					ТаблицаПоиска.Колонки.Добавить("Вложенность");          //формулы в (), которые могут приводить к x/0
					ТаблицаПоиска.Колонки.Добавить("НачальнаяПозиция");     //Все статьи и константы ранее были помещены в ()
					ТаблицаПоиска.Колонки.Добавить("КонечнаяПозиция");		  //для попадания в эту обработку
					ТаблицаПоиска.Колонки.Добавить("Родитель");
					ТаблицаПоиска.Колонки.Добавить("Блок");
					ТаблицаПоиска.Колонки.Добавить("БлокИзначальный");
					
					ОсновнаяФормула = ТаблицаПоиска.Добавить();				      //Добавляем саму формулу как нулевую вложенность
					ОсновнаяФормула.Идентификатор 	= "{0}";
					ОсновнаяФормула.Вложенность		= 0;
					ОсновнаяФормула.Родитель		= "{n}";
					ОсновнаяФормула.Блок			= Значение;
					ОсновнаяФормула.БлокИзначальный	= Значение;
				
					
					Для Н = 1 По ЧислоСиволов Цикл  						//Обход всхе символов формулы
						
						ТекущийСимвол = Сред(Значение, Н, 1);
						
						Если ТекущийСимвол = "(" Тогда   									            //Если ( -> Вложенность увеличивается
							                                                				    //и начинается получение блока
							Вложенность = Вложенность + 1;                  				    //Если есть (a + (b - c))
							НовыйБлок	= ТаблицаПоиска.Добавить();         				      //то в таблице поиска будет:
							НовыйБлок.Идентификатор 	= "{" + Идентификатор + "}";    	//(a + (b - c)) 	c вложенностью 1
							НовыйБлок.Вложенность		= Вложенность;     					        //(b - c) 			с вложенностью 2
							НовыйБлок.НачальнаяПозиция  = Н;
							НовыйБлок.Родитель			= ?(Вложенность = 1, "{0}", МассивРодителей[МассивРодителей.ВГраница()]);
							
							МассивРодителей.Добавить("{" + Идентификатор + "}");			//Добавляем коллекцию для связи с возможными дочерними элементами
							МаксимальнаяВложенность = ?(МаксимальнаяВложенность < Вложенность, Вложенность, МаксимальнаяВложенность);
							Идентификатор 			= Идентификатор + 1;
							
						ИначеЕсли ТекущийСимвол = ")" Тогда                 				//Если ) -> Вложенность уменьшается
							                                                				  //получение блока заканчивается
							Для каждого БлокПоиска Из ТаблицаПоиска Цикл
								Если БлокПоиска.Вложенность = Вложенность И Не ЗначениеЗаполнено(БлокПоиска.КонечнаяПозиция) Тогда
									БлокПоиска.КонечнаяПозиция 	= Н + 1;	
									БлокПоиска.Блок				= Сред(Значение, БлокПоиска.НачальнаяПозиция, БлокПоиска.КонечнаяПозиция - БлокПоиска.НачальнаяПозиция);
									БлокПоиска.БлокИзначальный  = БлокПоиска.Блок;
									
									Прервать;
								КонецЕсли; 
							КонецЦикла; 
							
							МассивРодителей.Удалить(МассивРодителей.ВГраница()); 			//Блок закрыт -> вложенных элементов быть не может
							Вложенность = Вложенность - 1;
							
							Если Вложенность = 0 Тогда
							КонецЕсли; 
						КонецЕсли; 
						
					КонецЦикла;
							
					
					Н = МаксимальнаяВложенность;
					Пока Н >= 0  Цикл                            							        //Обход таблицы поиска начиная с 
																							                              //максимальной вложенности
						Отбор 					= Новый Структура("Вложенность", Н);            //с заменой дочернего блока в родителе
						БлокиПолученные 		= ТаблицаПоиска.НайтиСтроки(Отбор);         //на его идентификатор
						БлокиТекущейВложенности = Новый Массив;
						
						Для Л = 0 По БлокиПолученные.ВГраница() Цикл    					        //Сортировка массива по длине блока
							                                                                //чтобы в начале заменялись
							Добавлен = Ложь;                                                //большие блоки
							
							Если БлокиТекущейВложенности.Количество() = 0 Тогда
								 БлокиТекущейВложенности.Добавить(БлокиПолученные[Л]);
								 Продолжить;
							КонецЕсли; 
							
							Для О = 0 По БлокиТекущейВложенности.ВГраница() Цикл
								Если СтрДлина(БлокиТекущейВложенности[О].БлокИзначальный) < СтрДлина(БлокиПолученные[Л].БлокИзначальный) Тогда
									БлокиТекущейВложенности.Вставить(О, БлокиПолученные[Л]);
									Добавлен = Истина;
									Прервать;
								КонецЕсли; 	
							КонецЦикла; 
							
							Если Не Добавлен Тогда
								БлокиТекущейВложенности.Добавить(БлокиПолученные[Л]);
								Продолжить;
							КонецЕсли; 
							
						КонецЦикла; 						
						
						Для каждого БлокПоиска Из БлокиТекущейВложенности Цикл              //Блок {1}: (a + b), Родитель {2}: c + (a + b) 
							Если БлокПоиска.Родитель <> "{n}" Тогда                         //-> {2}: c + {1}
								
								БлокРодитель = ТаблицаПоиска.Найти(БлокПоиска.Родитель, "Идентификатор");
								БлокРодитель.Блок = СтрЗаменитьПервое(БлокРодитель.Блок, БлокПоиска.БлокИзначальный, БлокПоиска.Идентификатор);
								
							КонецЕсли;                                             
						КонецЦикла;
						
						Н = Н - 1;
						
					КонецЦикла;
									
					МассивОбозначений			= Новый Массив;               														                            //В функции может быть несколько одинаковых операндов
					МассивПросмотренныхБлоков 	= Новый Массив;                                                                 //например 2 раза деление на 100
					СчетчикОбозначений			= 0;                                                                                //При этом неправильно отрабатывает СтрЗаменить, когда ВЫБОР или КОНЕЦ
					                                                                                                            //нужно добавить только к конкретному операнду
					Для каждого Блок Из ТаблицаПоиска Цикл                                                                      //Для этого ко всем одинаковым операндам добавляется & и номер
						                                                                                                          //[1] / 100&1 + [2] / 100&2 
						НайденВПросмотренных = Ложь;
						
						Для каждого ПросмотренныйБлок Из МассивПросмотренныхБлоков Цикл
							                                                                                                         //При обходе ранее обработанных блоков там уже может быть &
							ТекущийПросмотренныйБлок = ПросмотренныйБлок.Блок;                                                       //-> для сравнения с новым нужно этот & убрать
							
							Для каждого Обозначение Из МассивОбозначений Цикл
								ТекущийПросмотренныйБлок = СтрЗаменить(ТекущийПросмотренныйБлок, Обозначение, "");
							КонецЦикла; 
							
							Если Блок.Блок = ТекущийПросмотренныйБлок Тогда				                                             //Если истина -> Такой операнд уже был	
								НайденВПросмотренных = Истина;
								Прервать;
							КонецЕсли; 
							
						КонецЦикла; 
						
						Если НайденВПросмотренных Тогда
							
							Если Не СтрНайти(ПросмотренныйБлок.Блок, "&") > 0 Тогда                                                  //Если операнд повторяется больше чем 2 раза, то & уже будет от предыдущих проверок
								СчетчикОбозначений		= СчетчикОбозначений + 1;                                                        //и заново его добавлять не надо. Если это второе появление -> & добавляется
								ОбозначениеРаннего 		= "&" + Строка(СчетчикОбозначений);	                                             //на оба операнда (иначе первый операнд без & заменит все до & у второго)
								ПросмотренныйБлок.Блок 	= Лев(ПросмотренныйБлок.Блок, СтрДлина(ПросмотренныйБлок.Блок) - 1) + ОбозначениеРаннего 	+ ")";	
								МассивОбозначений.Добавить(ОбозначениеРаннего);
							КонецЕсли; 
							
							СчетчикОбозначений		= СчетчикОбозначений + 1;
							ОбозначениеПозднего 	= "&" + Строка(СчетчикОбозначений);                                                              //Добавление к текущему
							Блок.Блок 				= Лев(Блок.Блок				, СтрДлина(Блок.Блок) - 1) 				+ ОбозначениеПозднего 	+ ")";
							МассивОбозначений.Добавить(ОбозначениеПозднего);
							
							Блок.БлокИзначальный 				= Блок.Блок;
							ПросмотренныйБлок.БлокИзначальный 	= ПросмотренныйБлок.Блок;
							
						Иначе
							МассивПросмотренныхБлоков.Добавить(Блок);	                    	      //Если текущий встречается первый раз в формуле
						КонецЕсли; 
						
					КонецЦикла; 
					
					
					Для Н = 0 По МаксимальнаяВложенность Цикл     							              //Обход формулы начиная с минимальной сложности
						
						Отбор					          = Новый Структура("Вложенность", Н);            //Поиск строк по вложенности
						БлокиТекущейВложенности	= ТаблицаПоиска.НайтиСтроки(Отбор);
						
						Для каждого БлокПоиска Из БлокиТекущейВложенности Цикл
							
							МассивБлок 			    = Стрразделить(БлокПоиска.Блок, "/");             //Делим блок по знаку деления
							МассивОбработанный  = МассивБлок;
														
							Для Ф = 0  По МассивБлок.ВГраница() - 1 Цикл                         //Пропускаем первый элемент, так как он не может быть делителем
								
								М 					= МассивБлок.ВГраница() - Ф;
								ЧастьБлока 	= СокрЛП(МассивБлок[М]);                                                                                                                //Массив разделен по / -> все элементы после [0] - делители
								ПроверяемыйОператор = СокрЛП(Сред(ЧастьБлока, СтрНайти(ЧастьБлока, "{",,,1), СтрНайти(ЧастьБлока, "}",,,1) - СтрНайти(ЧастьБлока, "{",,,1) + 1));   //Ищем первый оператор в делителе
															
								Завершено 	= Ложь;
								Откат 		= 1;
								
								Пока Не Завершено Цикл 			//Если начало выражения для проверки не было найдено до предыдущего деления - переходим к числителю предыдущего деления
									
									НачалоВыражения = СокрЛП(МассивБлок[М - Откат]);
															
									Счетчик = 1;
									ОперандНачала = СокрЛП(Сред(НачалоВыражения       											//Делимое при делении
									, СтрНайти(НачалоВыражения, "{", НаправлениеПоиска.СКонца,,1)
									, СтрНайти(НачалоВыражения, "}", НаправлениеПоиска.СКонца,,1) - СтрНайти(НачалоВыражения, "{",,,1) + 1));
													
									Пока Не СтрНайти(НачалоВыражения, "{", НаправлениеПоиска.СКонца,,Счетчик) - 2 <= 0 Цикл   	//Пока не достигнуто начало выражения деления
										
										ЗнакПередПоследнимОперандом = Сред(НачалоВыражения, СтрНайти(НачалоВыражения, "{", НаправлениеПоиска.СКонца,,Счетчик) - 2, 1);                       //Здесь обрабатывается ситуация наличия * в делимом
										
																																                                          //Пример 1: a + b / c 		В этом случае проверка должна быть перед b 
										Если ЗнакПередПоследнимОперандом = "*" Тогда                                          //  a + Выбор Когда c = 0 Тогда 0 Иначе b / c Конец
											Счетчик = Счетчик + 1;                                                              //Пример 2: a * b / c		В этом случае проверка должна быть перед a
																																                                          //  Выбор Когда c = 0 Тогда 0 Иначе a * b / c Конец
											ОперандНачала = Сред(НачалоВыражения 												                        //Если найдено * -> Проверка должна включать предыдущий                                                                                                           
											, СтрНайти(НачалоВыражения, "{", НаправлениеПоиска.СКонца,,Счетчик)                 //операнд тоже. 
											, -1) ;	         																	                                  //Если во втором примере поставить проверку перед последним операндом то
										Иначе                                                                                 //порядок действий нарушится
											Завершено = Истина;
											Прервать;
										КонецЕсли; 
										
									КонецЦикла;
									
									Если Завершено Или М - Откат = 0 Тогда    				//Если достигнуто начало формулы или знак не "*" и не "/"
										Прервать;
									Иначе 
										Откат = Откат + 1;
									КонецЕсли; 
									
								КонецЦикла; 

								Конец 				= "";
								ЧислоВхождений 		= 0;
								
								Если СтрНайти(НачалоВыражения, "Конец") > 0 Тогда                                     //Если числитель уже сам был в проверке, т.е сейчас сформировался
									ЧислоВхождений 	= СтрЧислоВхождений(НачалоВыражения	, "Конец");
									НачалоВыражения = СтрЗаменить(НачалоВыражения		, "Конец", "");						          //вложенный ВЫБОР КОГДА, то КОНЕЦ верхнего выбора надо перекинуть в конец выражения	
				          ОперандНачала	  = СтрЗаменить(ОперандНачала			, "Конец", "");                   	//чтобы он не завершил раньше времени нижний ВЫБОР КОГДА
								КонецЕсли;                                                                                  
								
								Для Ю = 1 По ЧислоВхождений Цикл
									Конец = Конец + " Конец ";	
								КонецЦикла; 
								
								МассивОбработанный.Установить(М - Откат	, СтрЗаменить(НачалоВыражения, ОперандНачала, "ВЫБОР КОГДА " + ПроверяемыйОператор + " = 0 ТОГДА 0 Иначе " + ОперандНачала));  //Добавляем проверку
								МассивОбработанный.Установить(М			, СтрЗаменить(ЧастьБлока, ПроверяемыйОператор, ПроверяемыйОператор + " Конец " + Конец));  														
								
							КонецЦикла; 
							
							БлокПоиска.Блок = "";
							Р = 0;
							
							Для каждого ЧастьБлока Из МассивОбработанный Цикл  												//Сбор массива обратно в строку, замена блока без проверки на блок с проверкой
								БлокПоиска.Блок = БлокПоиска.Блок + ЧастьБлока + ?(Р = МассивБлок.ВГраница(), "", " / ");	
								Р = Р + 1;
							КонецЦикла; 
							
						КонецЦикла; 
											
					КонецЦикла;
					
					ТаблицаПоиска.Сортировать("Вложенность"); 				//Сортируем по вложенности для потепенной замены идентификаторов обратно на блоки 
					ФормулаСПроверками	= ТаблицаПоиска[0].Блок;			//Достаем формулу из нулевой вложенности
					
					Для каждого Блок Из ТаблицаПоиска Цикл
						ФормулаСПроверками = СтрЗаменить(ФормулаСПроверками, Блок.Идентификатор, Блок.Блок);
					КонецЦикла;
					
					Для Н = 0 По МассивОбозначений.ВГраница()  Цикл
						ФормулаСПроверками = СтрЗаменить(ФормулаСПроверками, МассивОбозначений[МассивОбозначений.ВГраница() - Н], "");
					КонецЦикла; 
					
					ФормулаСПроверками = СтрЗаменить(ФормулаСПроверками, "(<"	, "<");     //Убираем лишние скобки
					ФормулаСПроверками = СтрЗаменить(ФормулаСПроверками, "(["	, "[");
					ФормулаСПроверками = СтрЗаменить(ФормулаСПроверками, ">)"	, ">");
					ФормулаСПроверками = СтрЗаменить(ФормулаСПроверками, "])"	, "]");
					
					Выходная = ФормулаСПроверками;

         //Выходная - результат

КонецПроцедуры

Функция СтрЗаменитьПервое(Знач ИсходнаяСтрока, Знач ПодстрокаПоиска, Знач ПодстрокаЗамены) Экспорт
    
    ПозицияЗамены = Найти(ИсходнаяСтрока, ПодстрокаПоиска);
	
    Если ПозицияЗамены > 0 Тогда
        ВтораяЧасть 	  = Сред(ИсходнаяСтрока, ПозицияЗамены + СтрДлина(ПодстрокаПоиска)); 
		    ИсходнаяСтрока 	= Лев(ИсходнаяСтрока, ПозицияЗамены - 1) + ПодстрокаЗамены + ВтораяЧасть;
    КонецЕсли; 

    Возврат ИсходнаяСтрока;

КонецФункции

